{"version":3,"file":"js/game-cd54052f3ed7990fd3ff.js","sources":["webpack:///webpack/bootstrap","webpack:///./app/javascript/packs/game.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/packs/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./app/javascript/packs/game.js\");\n","\r\n  var obstacleID = 9;\r\n  var boxID = 1;\r\n  var goalID = 3;\r\n  var charID = 2;\r\n  var freeID = 0;\r\n  var goalBoxID = 4;\r\n  var goalCharID = 5;\r\n\r\n  class TNode {\r\n    constructor(state, parent = null, children = [], q = 0, n = 0,\r\n        visited = false, exhausted = false, frozen = false, terminal = false) {\r\n      this.state = state;\r\n      this.parent = parent;\r\n      this.children = children;\r\n      this.q = q;\r\n      this.n = n;\r\n      this.visited = visited;\r\n      this.exhausted = exhausted;\r\n      this.frozen = frozen; // when frozen, copy state into this attribute\r\n      this.terminal = terminal;\r\n    }\r\n\r\n    isRoot() {\r\n      if (this.parent === null) {\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    isVisited() {\r\n      if (this.visited === true) {\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    isExhausted() {\r\n      if (this.exhausted === true) {\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    isFrozen() {\r\n      if (this.frozen === false) {\r\n        return false;\r\n      } else {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    isTerminal() {\r\n      if (this.terminal === true) {\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  // Testing\r\n  var testRoot = mctsInit(5, 5);\r\n  var testFrozen = [[9,0,9,0,9],[0,0,0,0,9],[0,9,2,0,9],[0,1,0,1,0],[9,0,0,0,9]];\r\n  var testState = [[9,0,9,0,9],[0,1,2,1,9],[0,9,0,0,9],[0,0,0,0,0],[9,0,0,0,9]];\r\n  var testNode = new TNode(state = testFrozen, parent = null, children = [], q = 0, n = 0, visited = false, exhausted = false, frozen = false, terminal = false)\r\n\r\n  postMessage(\"Worker started!\");\r\n\r\n  //newPuzzle = mctsMain(mctsInit(5, 5), 60000);\r\n  //postMessage(newPuzzle);\r\n\r\n\r\n  function mctsInit(m, n) { // creates root (m by n) filled with obstacles\r\n    var state = Array.from({ length: n},\r\n      () => Array.from({length: m}, () => obstacleID));\r\n    state[Math.trunc(state.length / 2)][Math.trunc(state[0].length / 2)]\r\n      = freeID + 2;\r\n\r\n    return new TNode(state, parent = null, children = [], q = 0, n = 0, visited = false, exhausted = false, frozen = false, terminal = false);\r\n  }\r\n\r\n\r\n  function mctsSim(node) { // full simulation/rollout\r\n    //console.log(\"Starting Sim call\", node);\r\n    var nodeCur = node;\r\n\r\n    //if (nodeCur.children.length === 0) console.log(\"Creating children\");\r\n\r\n    // create child nodes if necessary, but still let it go through visited nodes\r\n    while (nodeCur.isFrozen() === false) {\r\n      //console.log(\"Starting first sim while\", nodeCur.parent);\r\n      if (nodeCur.children.length === 0) mctsAct1(nodeCur);\r\n      nodeCur = mctsRoll(nodeCur);\r\n    }\r\n\r\n    while (nodeCur.isTerminal() === false) {\r\n      //console.log(\"Starting second sim while\", nodeCur);\r\n      if (nodeCur.children.length === 0) mctsAct2(nodeCur);\r\n      nodeCur = mctsRoll(nodeCur);\r\n    }\r\n    node.visited = true;\r\n    mctsProp(node, mctsEval(nodeCur));\r\n    console.log(\"Ending Sim call\", nodeCur.parent);\r\n    return node;\r\n  }\r\n\r\n\r\n  function mctsMain(root, timeLimit) {\r\n    mctsSim(root);\r\n    var startTime = Date.now();\r\n    while (Date.now() - startTime < timeLimit) {\r\n      //console.log(\"Starting main while loop\");\r\n      var nodeCur = mctsTrav(root);\r\n      if (nodeCur.isTerminal()) {\r\n        mctsSim(nodeCur);\r\n      } else {\r\n        mctsExpl(nodeCur);\r\n      }\r\n    }\r\n    var puzzle = root;\r\n    while (puzzle.isTerminal() === false) {\r\n      puzzle = mctsBest(puzzle);\r\n    }\r\n    console.log(\"Evaluation:\", mctsEval(puzzle));\r\n    console.log(\"Result:\", puzzle);\r\n    return puzzle;\r\n  }\r\n\r\n\r\n  function mctsExpl(node) { // exhaust a node by starting sim at each child\r\n    //console.log(\"Starting Expl call\", node);\r\n    for (child = 0; child < node.children.length; child++) {\r\n      mctsSim(node.children[child]);\r\n      node.exhausted = true;\r\n    }\r\n    //console.log(\"Ending Expl call\", node);\r\n    return node\r\n  }\r\n\r\n\r\n  function mctsTrav(node) { // traverse down to the uct-best unexhausted node\r\n    //console.log(\"Starting Trav call\");\r\n    var nodeCurrent = node;\r\n    while (nodeCurrent.isExhausted()) {\r\n      var bestUCT = 0;\r\n      var nodeNext = null;\r\n      for (i = 0; i < nodeCurrent.children.length; i++) {\r\n        //console.log(nodeCurrent, nodeCurrent.children[i]);\r\n        var uct = mctsUCT(nodeCurrent, nodeCurrent.children[i]);\r\n        if (uct >= bestUCT) {\r\n          bestUCT = uct;\r\n          nodeNext = nodeCurrent.children[i];\r\n        }\r\n      }\r\n      nodeCurrent = nodeNext;\r\n    }\r\n    //console.log(\"Ending Trav call\", nodeCurrent);\r\n    return nodeCurrent;\r\n    }\r\n\r\n\r\n  function mctsBest(node) { // choose best child (num times propagated thru)\r\n    var best = [null, 0];\r\n    for (i = 0; i < node.children.length; i++) {\r\n      maxer = node.children[i].n;\r\n      if (maxer >= best[1]) {\r\n        best = [node.children[i], maxer];\r\n      }\r\n    }\r\n\r\n    return best[0];\r\n  }\r\n\r\n  function mctsRoll(node) { // rollout policy, i.e. pick random child\r\n    roll = Math.random();\r\n    numCh = node.children.length;\r\n    for (i = 0; i < numCh; i++) {\r\n      if (roll <= (i + 1) / numCh) {\r\n        return node.children[i];\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  function mctsAct1(node) { // create child nodes, unfrozen\r\n    var neighbors = [0, 0, 0, 0];\r\n    var deleted = false;\r\n    var newState = JSON.parse(JSON.stringify(node.state));\r\n\r\n    for (i = 0; i < node.state.length; i++) {\r\n      for (j = 0; j < node.state[i].length; j++) {\r\n        if (node.state[i][j] === obstacleID) {\r\n          neighbors = [j+1, i+1, j-1, i-1]; // right, up, left, down\r\n          deleted = false;\r\n          // delete obstacles adjacent to non-obstacles\r\n\r\n          if (deleted === false && neighbors[0] < node.state[i].length) {\r\n            if (node.state[i][neighbors[0]] !== obstacleID) {\r\n              newState[i][j] = freeID;\r\n              node.children.push(new TNode(state = JSON.parse(JSON.stringify(newState)), parent = node));\r\n              deleted = true;\r\n              newState[i][j] = obstacleID;\r\n            }\r\n          }\r\n\r\n          if (deleted === false && neighbors[1] < node.state.length) {\r\n            if (node.state[neighbors[1]][j] !== obstacleID) {\r\n              newState[i][j] = freeID;\r\n              node.children.push(new TNode(state = JSON.parse(JSON.stringify(newState)), parent = node));\r\n              deleted = true;\r\n              newState[i][j] = obstacleID;\r\n            }\r\n          }\r\n\r\n          if (deleted === false && neighbors[2] >= 0) {\r\n            if (node.state[i][neighbors[2]] !== obstacleID) {\r\n              newState[i][j] = freeID;\r\n              node.children.push(new TNode(state = JSON.parse(JSON.stringify(newState)), parent = node));\r\n              deleted = true;\r\n              newState[i][j] = obstacleID;\r\n            }\r\n          }\r\n\r\n          if (deleted === false && neighbors[3] >= 0) {\r\n            if (node.state[neighbors[3]][j] !== obstacleID) {\r\n              newState[i][j] = freeID;\r\n              node.children.push(new TNode(state = JSON.parse(JSON.stringify(newState)), parent = node));\r\n              deleted = true;\r\n              newState[i][j] = obstacleID;\r\n            }\r\n          }\r\n\r\n        }\r\n      }\r\n    }\r\n\r\n    newState = JSON.parse(JSON.stringify(node.state));\r\n    for (i = 0; i < node.state.length; i++) {\r\n      for (j = 0; j < node.state[i].length; j++) {\r\n        if (node.state[i][j] === freeID) {\r\n          // place box\r\n          newState[i][j] = boxID;\r\n          node.children.push(new TNode(state = JSON.parse(JSON.stringify(newState)), parent = node));\r\n          newState[i][j] = freeID;\r\n        }\r\n      }\r\n    }\r\n    // freeze level if we have any boxes\r\n    var boxCount = 0;\r\n    for (i = 0; i < node.state.length; i++) {\r\n      for (j = 0; j < node.state[i].length; j++) {\r\n        if (node.state[i][j] == boxID) {\r\n          boxCount++;\r\n        }\r\n      }\r\n    }\r\n    if (boxCount > 0) {\r\n      node.children.push(new TNode(state = node.state, parent = node, children = [], q = 0, n = 0, visited = false, exhausted = false, frozen = node.state));\r\n    }\r\n    return node;\r\n  }\r\n\r\n\r\n  function mctsAct2(node) { // create child nodes, frozen\r\n    var neighbor = 0;\r\n    var neighbor2 = 0;\r\n    var newState = JSON.parse(JSON.stringify(node.state));\r\n\r\n    for (i = 0; i < node.state.length; i++) {\r\n      for (j = 0; j < node.state[i].length; j++) {\r\n        if (node.state[i][j] === charID || node.state[i][j] === goalCharID) {\r\n          neighbors = [j+1, i+1, j-1, i-1];\r\n          // move agent, possibly pushing boxes\r\n\r\n          neighbor = j + 1;\r\n          neighbor2 = j + 2;\r\n          if (neighbor < node.state[i].length) {\r\n            if (node.state[i][neighbor] === freeID || node.state[i][neighbor] === goalID) {\r\n              newState[i][neighbor] += 2;\r\n              newState[i][j] -= 2;\r\n              node.children.push(new TNode(state = JSON.parse(JSON.stringify(newState)), parent = node, children = [], q = 0, n = 0, visited = false, exhausted = false, frozen = node.frozen));\r\n              newState[i][neighbor] -= 2;\r\n              newState[i][j] += 2;\r\n            }\r\n            if (node.state[i][neighbor] === boxID || node.state[i][neighbor] === goalBoxID) {\r\n              if (neighbor2 < node.state[i].length) {\r\n                if (node.state[i][neighbor2] != obstacleID\r\n                && node.state[i][neighbor2] != boxID\r\n                && node.state[i][neighbor2] != goalBoxID) {\r\n                  newState[i][neighbor] += 2;\r\n                  newState[i][j] -= 2;\r\n                  newState[i][neighbor2] += 1;\r\n                  newState[i][neighbor] -= 1;\r\n                  node.children.push(new TNode(state = JSON.parse(JSON.stringify(newState)), parent = node, children = [], q = 0, n = 0, visited = false, exhausted = false, frozen = node.frozen));\r\n                  newState[i][neighbor] -= 2;\r\n                  newState[i][j] += 2;\r\n                  newState[i][neighbor2] -= 1;\r\n                  newState[i][neighbor] += 1;\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          neighbor = i + 1;\r\n          neighbor2 = i + 2;\r\n          if (neighbor < node.state.length) {\r\n            if (node.state[neighbor][j] === freeID || node.state[neighbor][j] === goalID) {\r\n              newState[neighbor][j] += 2;\r\n              newState[i][j] -= 2;\r\n              node.children.push(new TNode(state = JSON.parse(JSON.stringify(newState)), parent = node, children = [], q = 0, n = 0, visited = false, exhausted = false, frozen = node.frozen));\r\n              newState[neighbor][j] -= 2;\r\n              newState[i][j] += 2;\r\n            }\r\n            if (node.state[neighbor][j] === boxID || node.state[neighbor][j] === goalBoxID) {\r\n              if (neighbor2 < node.state.length) {\r\n                if (node.state[neighbor2][j] != obstacleID\r\n                && node.state[neighbor2][j] != boxID\r\n                && node.state[neighbor2][j] != goalBoxID) {\r\n                  newState[neighbor][j] += 2;\r\n                  newState[i][j] -= 2;\r\n                  newState[neighbor2][j] += 1;\r\n                  newState[neighbor][j] -= 1;\r\n                  node.children.push(new TNode(state = JSON.parse(JSON.stringify(newState)), parent = node, children = [], q = 0, n = 0, visited = false, exhausted = false, frozen = node.frozen));\r\n                  newState[neighbor][j] -= 2;\r\n                  newState[i][j] += 2;\r\n                  newState[neighbor2][j] -= 1;\r\n                  newState[neighbor][j] += 1;\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          neighbor = j - 1;\r\n          neighbor2 = j - 2;\r\n          if (neighbor >= 0) {\r\n            if (node.state[i][neighbor] === freeID || node.state[i][neighbor] === goalID) {\r\n              newState[i][neighbor] += 2;\r\n              newState[i][j] -= 2;\r\n              node.children.push(new TNode(state = JSON.parse(JSON.stringify(newState)), parent = node, children = [], q = 0, n = 0, visited = false, exhausted = false, frozen = node.frozen));\r\n              newState[i][neighbor] -= 2;\r\n              newState[i][j] += 2;\r\n            }\r\n            if (node.state[i][neighbor] === boxID || node.state[i][neighbor] === goalBoxID) {\r\n              if (neighbor2 >= 0) {\r\n                if (node.state[i][neighbor2] != obstacleID\r\n                && node.state[i][neighbor2] != boxID\r\n                && node.state[i][neighbor2] != goalBoxID) {\r\n                  newState[i][neighbor] += 2;\r\n                  newState[i][j] -= 2;\r\n                  newState[i][neighbor2] += 1;\r\n                  newState[i][neighbor] -= 1;\r\n                  node.children.push(new TNode(state = JSON.parse(JSON.stringify(newState)), parent = node, children = [], q = 0, n = 0, visited = false, exhausted = false, frozen = node.frozen));\r\n                  newState[i][neighbor] -= 2;\r\n                  newState[i][j] += 2;\r\n                  newState[i][neighbor2] -= 1;\r\n                  newState[i][neighbor] += 1;\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          neighbor = i - 1;\r\n          neighbor2 = i - 2;\r\n          if (neighbor >= 0) {\r\n            if (node.state[neighbor][j] === freeID || node.state[neighbor][j] === goalID) {\r\n              newState[neighbor][j] += 2;\r\n              newState[i][j] -= 2;\r\n              node.children.push(new TNode(state = JSON.parse(JSON.stringify(newState)), parent = node, children = [], q = 0, n = 0, visited = false, exhausted = false, frozen = node.frozen));\r\n              newState[neighbor][j] -= 2;\r\n              newState[i][j] += 2;\r\n            }\r\n            if (node.state[neighbor][j] === boxID || node.state[neighbor][j] === goalBoxID) {\r\n              if (neighbor2 >= 0) {\r\n                if (node.state[neighbor2][j] != obstacleID\r\n                && node.state[neighbor2][j] != boxID\r\n                && node.state[neighbor2][j] != goalBoxID) {\r\n                  newState[neighbor][j] += 2;\r\n                  newState[i][j] -= 2;\r\n                  newState[neighbor2][j] += 1;\r\n                  newState[neighbor][j] -= 1;\r\n                  node.children.push(new TNode(state = JSON.parse(JSON.stringify(newState)), parent = node, children = [], q = 0, n = 0, visited = false, exhausted = false, frozen = node.frozen));\r\n                  newState[neighbor][j] -= 2;\r\n                  newState[i][j] += 2;\r\n                  newState[neighbor2][j] -= 1;\r\n                  newState[neighbor][j] += 1;\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n        }\r\n      }\r\n    }\r\n\r\n    // evaluate level, terminal node\r\n    newState = JSON.parse(JSON.stringify(node.state));\r\n/*\r\n    for (i = 0; i < node.state.length; i++) {\r\n      for (j = 0; j < node.state[i].length; j++) {\r\n\r\n        // change current boxes into goals\r\n        if (newState[i][j] === boxID) {\r\n          newState[i][j] = goalID;\r\n        }\r\n\r\n        console.log(\"After c boxes -> goals\", JSON.parse(JSON.stringify(newState)));\r\n\r\n        // move the agent back to where they started\r\n        if (newState[i][j] === charID || newState[i][j] === goalCharID) {\r\n          newState[i][j] -= 2;\r\n          newState[Math.trunc(state.length / 2)][Math.trunc(state[0].length / 2)] += 2;\r\n        }\r\n\r\n        console.log(\"After move agent to start\", JSON.parse(JSON.stringify(newState)));\r\n\r\n        // restore frozen (original) box locations\r\n        if (node.frozen[i][j] === boxID) {\r\n          newState[i][j] += 1;\r\n        }\r\n\r\n        console.log(\"After restore frozen boxes\", JSON.parse(JSON.stringify(newState)));\r\n\r\n        // postprocessing: unused boxes -> obstacle tile\r\n        if (newState[i][j] === goalBoxID) {\r\n          newState[i][j] = obstacleID;\r\n        }\r\n\r\n        console.log(\"After postprocessing\", JSON.parse(JSON.stringify(newState)));\r\n      }\r\n    }\r\n    */\r\n\r\n    for (i = 0; i < node.state.length; i++) {\r\n      for (j = 0; j < node.state[i].length; j++) {\r\n        // change current boxes into goals\r\n        if (newState[i][j] === boxID) {\r\n          newState[i][j] = goalID;\r\n        }\r\n      }\r\n    }\r\n\r\n    for (i = 0; i < node.state.length; i++) {\r\n      for (j = 0; j < node.state[i].length; j++) {\r\n        // move the agent back to where they started\r\n        if (newState[i][j] === charID || newState[i][j] === goalCharID) {\r\n          newState[i][j] -= 2;\r\n          newState[Math.trunc(state.length / 2)][Math.trunc(state[0].length / 2)] += 2;\r\n        }\r\n      }\r\n    }\r\n\r\n    for (i = 0; i < node.state.length; i++) {\r\n      for (j = 0; j < node.state[i].length; j++) {\r\n        // restore frozen (original) box locations\r\n        if (node.frozen[i][j] === boxID) {\r\n          newState[i][j] += 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    for (i = 0; i < node.state.length; i++) {\r\n      for (j = 0; j < node.state[i].length; j++) {\r\n        // postprocessing: unused boxes -> obstacle tile\r\n        if (newState[i][j] === goalBoxID) {\r\n          newState[i][j] = obstacleID;\r\n        }\r\n      }\r\n    }\r\n\r\n    node.children.push(new TNode(state = JSON.parse(JSON.stringify(newState)), parent = node, children = [], q = 0, n = 0, visited = false, exhausted = false, frozen = node.frozen, terminal = true))\r\n    return node;\r\n  }\r\n\r\n\r\n  function mctsProp(node, result) { // recursively backpropagate to root\r\n    node.q += result;\r\n    node.n += 1;\r\n\r\n    if (node.isRoot()) {\r\n      return;\r\n    }\r\n\r\n    mctsProp(node.parent, result);\r\n  }\r\n\r\n  function mctsEval(node) { // equation 2 from paper\r\n    var terrain = 0;\r\n    var congestion = 0;\r\n\r\n    var neighbors = [0, 0, 0, 0];\r\n\r\n    // constant parameters\r\n    var a = 4;\r\n    var b = 4;\r\n    var c = 1;\r\n    var k = 200;\r\n    var w1 = 5;\r\n    var w2 = 5;\r\n    var w3 = 2;\r\n\r\n    var boxes = [];\r\n    var goalsUnordered = [];\r\n\r\n    for (i = 0; i < node.state.length; i++) {\r\n      for (j = 0; j < node.state[i].length; j++) {\r\n        if (node.state[i][j] === freeID || node.state[i][j] === freeID + 1 ||\r\n            node.state[i][j] === freeID + 2) {\r\n          neighbors = [j+1, i+1, j-1, i-1]; // right, up, left, down\r\n\r\n          if (neighbors[0] < node.state[i].length) {\r\n            if (node.state[i][neighbors[0]] === obstacleID) {\r\n              terrain++;\r\n            }\r\n          }\r\n\r\n          if (neighbors[1] < node.state.length) {\r\n            if (node.state[neighbors[1]][j] === obstacleID) {\r\n              terrain++;\r\n            }\r\n          }\r\n\r\n          if (neighbors[2] >= 0) {\r\n            if (node.state[i][neighbors[2]] === obstacleID) {\r\n              terrain++;\r\n            }\r\n          }\r\n\r\n          if (neighbors[3] >= 0) {\r\n            if (node.state[neighbors[3]][j] === obstacleID) {\r\n              terrain++;\r\n            }\r\n          }\r\n\r\n        }\r\n\r\n        if (node.state[i][j] === boxID) {\r\n          boxes.push([i, j]);\r\n        }\r\n\r\n        if (node.state[i][j] === goalID || node.state[i][j] === goalCharID) {\r\n          goalsUnordered.push([i, j]);\r\n        }\r\n\r\n      }\r\n    }\r\n\r\n    var goals = [];\r\n    for (box = 0; box < boxes.length; box++) {\r\n      var shortest = [Number.POSITIVE_INFINITY, goalsUnordered[box]];\r\n      for (goal = 0; goal < goalsUnordered.length; goal++) {\r\n        var dist = Math.sqrt((boxes[box][0] - goalsUnordered[goal][0])**2\r\n          + (boxes[box][1] - goalsUnordered[goal][1])**2);\r\n        if (dist < shortest[0]) {\r\n          shortest[0] = dist;\r\n          shortest[1] = goal; // index in the goalsUnordered array\r\n        }\r\n\r\n      }\r\n      goals.push(goalsUnordered[shortest[1]]); // reorder corresponding to boxes\r\n      goalsUnordered.splice(shortest[1], 1);\r\n    }\r\n    for (box = 0; box < boxes.length; box++) {\r\n      var boxCount = 0;\r\n      var goalCount = 0;\r\n      var obstacleCount = 0;\r\n      var areaCount = 0;\r\n\r\n      for (i = Math.min(boxes[box][0], goals[box][0]); i <= Math.max(boxes[box][0], goals[box][0]); i++) {\r\n        for (j = Math.min(boxes[box][1], goals[box][1]); j <= Math.max(boxes[box][1], goals[box][1]); j++) {\r\n          if (node.state[i][j] === boxID) {\r\n            boxCount += 1;\r\n          }\r\n          if (node.state[i][j] === goalID) {\r\n            goalCount += 1;\r\n          }\r\n          if (node.state[i][j] === obstacleID) {\r\n            obstacleCount += 1;\r\n          }\r\n          areaCount += 1;\r\n        }\r\n      }\r\n      congestion +=\r\n        (a * boxCount + b * goalCount) / (c * (areaCount - obstacleCount))\r\n    }\r\n    return (w1 * terrain + w2 * congestion + w3 * boxes.length) / k;\r\n  }\r\n\r\n\r\n  function mctsUCT(node, child) { // used to decide between nodes in traversal\r\n    var c = Math.sqrt(2); // constant param, sqrt(2) is apparently standard\r\n    return (child.q / child.n) + c * (Math.sqrt(Math.log(node.n) / child.n));\r\n  }\r\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AADA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAAA;AACA;;;;A","sourceRoot":""}